/*
 * TSC2046_STM32_HardwareManager.c
 *
 *  Created on: Jul 4, 2020
 *      Author: chris
 */


#include "TSC2046_STM32_HardwareManager.h"

#include "gpio.h"
#include "spi.h"

//#define TSC2046_USE_HAL

// Private Function Prototypes
void TSC2046_HM_ConvertToQVGA(uint16_t Positions[2]);
void _SetCsPinHigh();
void _SetCsPinLow();
void _EnableSPI();
void _SpiTransmit8(uint8_t data);
uint16_t _SpiReceive16();
void _SpiOverflowReset();
void _WaitDelay(uint16_t delay);

/*
 *
 *	@brief
 *
 *	@param None
 *	@retval
 *
 */
void TSC2046_HM_Init()
{
	TSC2046_HW_LOOP_TIMER->PSC = 0;
	TSC2046_HW_LOOP_TIMER->ARR = 4095;
	TSC2046_HW_LOOP_TIMER->CR1 |= TIM_CR1_CEN;
	TSC2046_HW_LOOP_TIMER->DIER |= TIM_DIER_UIE;
}

/*
 *
 *	@brief
 *
 *	@param None
 *	@retval
 *
 */
eTSC2046ReadStatusTypedef TSC2046_HM_ReadAnalogInput(uint16_t Positions[2])
{
	eTSC2046ReadStatusTypedef status = TSC2046_DATAOK;

#define XPOSCMD		0xD0
#define YPOSCMD		0x90


#ifdef TSC2046_USE_HAL
	// Control Bytes (8 bits)
	// https://www.ti.com/lit/ds/symlink/tsc2046.pdf
	uint8_t tsc2046_read_ypos_cmd[1] = { 0x90 };			// 1001 0000 - Read Y, 12-bit, DFR mode
	uint8_t tsc2046_read_xpos_cmd[1] = { 0xD0 };			// 1101 0000

	// Read Data Bytes (2 x 8 bits)
	uint8_t tsc2046_read_xpos_data[2] = {};
	uint8_t tsc2046_read_ypos_data[2] = {};
#else
	uint16_t tsc2046_read_xpos_data = 0;
	uint16_t tsc2046_read_ypos_data = 0;
#endif


	// pull CS line high - Pre-transaction reset
	#ifdef TSC2046_USE_HAL
		HAL_GPIO_WritePin(TS_CS_GPIO_Port, TS_CS_Pin, GPIO_PIN_SET);
	#else
		//TS_CS_GPIO_Port->ODR |= TS_CS_Pin;
		//_SetCsPinHigh();
	#endif

	if(TSC2046_EM_GetTouchScreenState() == TSC2046_ConversionState)
	{

	// Check SPI is enabled
		_EnableSPI();

	// START Transaction
		#ifdef TSC2046_USE_HAL
			HAL_GPIO_WritePin(TS_CS_GPIO_Port, TS_CS_Pin, GPIO_PIN_RESET);

			HAL_SPI_Transmit(&hspi2, tsc2046_read_xpos_cmd, 1, 1);
			HAL_SPI_Receive(&hspi2, tsc2046_read_xpos_data, 2, 1);

			HAL_SPI_Transmit(&hspi2, tsc2046_read_ypos_cmd, 1, 1);
			HAL_SPI_Receive(&hspi2, tsc2046_read_ypos_data, 2, 1);

			HAL_GPIO_WritePin(TS_CS_GPIO_Port, TS_CS_Pin, GPIO_PIN_SET);
		#else
			_SetCsPinLow();
			//_WaitDelay(100);

			_SpiTransmit8(YPOSCMD);							// Y POS CMD transmit
			_SpiReceive16();								// dummy receive

			//_WaitDelay(0);

			_SpiTransmit8(YPOSCMD);							// Y POS CMD transmit
			tsc2046_read_ypos_data = _SpiReceive16();		// Y POS receive

			//_WaitDelay(100);
			_SetCsPinHigh();

			_SetCsPinLow();
			//_WaitDelay(100);

			_SpiTransmit8(XPOSCMD);							// X POS CMD transmit
			_SpiReceive16();								// dummy receive

			//_WaitDelay(0);

			_SpiTransmit8(XPOSCMD);							// X POS CMD transmit
			tsc2046_read_xpos_data = _SpiReceive16();		// Y POS receive

			//_WaitDelay(100);
			_SetCsPinHigh();


		#endif


#ifdef TSC2046_USE_HAL

		#ifdef FLIP_TSC2046_COORDS
		    Positions[0] |= (uint16_t)tsc2046_read_ypos_data[0] << 8;
		    Positions[0] |= (uint16_t)tsc2046_read_ypos_data[1] << 0;

		    Positions[1] |= (uint16_t)tsc2046_read_xpos_data[0] << 8;
		    Positions[1] |= (uint16_t)tsc2046_read_xpos_data[1] << 0;
		#else
		    Positions[1] |= (uint16_t)tsc2046_read_xpos_data[0] << 8;
		    Positions[1] |= (uint16_t)tsc2046_read_xpos_data[1] << 0;

		    Positions[0] |= (uint16_t)tsc2046_read_ypos_data[0] << 8;
		    Positions[0] |= (uint16_t)tsc2046_read_ypos_data[1] << 0;
		#endif
#else
		#ifdef FLIP_TSC2046_COORDS
			Positions[0] = tsc2046_read_ypos_data;
			Positions[1] = tsc2046_read_xpos_data;
		#else
			Positions[0] = tsc2046_read_xpos_data;
			Positions[1] = tsc2046_read_ypos_data;
		#endif
#endif

	    TSC2046_HM_ConvertToQVGA(Positions);
	}
	else
	{
	    Positions[0] = 0;
	    Positions[1] = 0;
		status = TSC2046_DATAERR;
	}

	return status;

}

/*
 *
 *	@brief
 *
 *	@param None
 *	@retval
 *
 */
void TSC2046_HM_ConvertToQVGA(uint16_t pos[2])
{
	uint16_t QVGA_HORIZON = 	320;
	uint16_t QVGA_VERTICAL = 	240;

	pos[0] /= 100;
	pos[1] /= 100;

//	pos[0] *= -1;
//	pos[1] *= -1;

	// inverse
	pos[0] = QVGA_HORIZON - pos[0];
	pos[1] = QVGA_VERTICAL - pos[1];

	// offset
	pos[0] += 40;			// x
	pos[1] += 40;			// y

	// scale
	pos[0] *= 0.5;			// x
	pos[1] *= 0.5;			// y

}

void _SetCsPinHigh()
{
	TS_CS_GPIO_Port->ODR |= TS_CS_Pin;
}

void _SetCsPinLow()
{
	TS_CS_GPIO_Port->ODR &= ~TS_CS_Pin;
}

void _EnableSPI()
{
	// Check SPI is enabled
	if ((TSC2046_SPI->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
	{
		TSC2046_SPI->CR1 |= SPI_CR1_SPE;
	}

}

void _SpiTransmit8(uint8_t data)
{
	if ((SPI2->SR & SPI_SR_TXE) == SPI_SR_TXE)
	{
		*(volatile uint8_t *)&(SPI2->DR) = data;
	}
}

uint16_t _SpiReceive16()
{
	uint16_t data = 0;
	if ((SPI2->SR & SPI_SR_RXNE) == SPI_SR_RXNE)
	{
		data = (uint16_t)SPI2->DR;
	}
	return data;
}

void _SpiOverflowReset()
{
	SPI2->SR &= ~(SPI_SR_OVR);		// clear SPI overrun flag, if set
}

void _WaitDelay(uint16_t delay)
{
	for(int t=0 ; t<delay; t++)
		asm("NOP");
}
