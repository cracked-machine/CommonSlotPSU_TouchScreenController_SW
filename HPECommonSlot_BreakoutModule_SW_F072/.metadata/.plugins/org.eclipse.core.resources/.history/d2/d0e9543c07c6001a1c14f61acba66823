/*
 * TSC2046_STM32_HardwareManager.c
 *
 *  Created on: Jul 4, 2020
 *      Author: chris
 */


#include "TSC2046_STM32_HardwareManager.h"

#include "gpio.h"
#include "spi.h"

//#define TSC2046_USE_HAL

// Private Function Prototypes
void TSC2046_HM_ConvertToQVGA(uint16_t Positions[2]);
void _SetCsPinHigh();
void _SetCsPinLow();
void _EnableSPI();
void _SpiTransmit8(uint8_t data);
uint16_t _SpiReceive16();
void _SpiOverflowReset();

/*
 *
 *	@brief
 *
 *	@param None
 *	@retval
 *
 */
void TSC2046_HM_Init()
{
	TSC2046_HW_LOOP_TIMER->PSC = 0;
	TSC2046_HW_LOOP_TIMER->ARR = 4095;
	TSC2046_HW_LOOP_TIMER->CR1 |= TIM_CR1_CEN;
	TSC2046_HW_LOOP_TIMER->DIER |= TIM_DIER_UIE;
}

/*
 *
 *	@brief
 *
 *	@param None
 *	@retval
 *
 */
eTSC2046ReadStatusTypedef TSC2046_HM_ReadAnalogInput(uint16_t Positions[2])
{
	eTSC2046ReadStatusTypedef status = TSC2046_DATAOK;

	// Control Bytes (8 bits)
	// https://www.ti.com/lit/ds/symlink/tsc2046.pdf
#ifdef TSC2046_USE_HAL
	uint8_t tsc2046_read_ypos_cmd[1] = { 0x90 };			// 1001 0000 - Read Y, 12-bit, DFR mode
	uint8_t tsc2046_read_xpos_cmd[1] = { 0xD0 };			// 1101 0000

	// Read Data Bytes (2 x 8 bits)
	uint8_t tsc2046_read_xpos_data[2] = {};
	uint8_t tsc2046_read_ypos_data[2] = {};

#endif

	// pull CS line high - Pre-transaction reset
	#ifdef TSC2046_USE_HAL
		HAL_GPIO_WritePin(TS_CS_GPIO_Port, TS_CS_Pin, GPIO_PIN_SET);
	#else
		//TS_CS_GPIO_Port->ODR |= TS_CS_Pin;
		//_SetCsPinHigh();
	#endif

	if(TSC2046_EM_GetTouchScreenState() == TSC2046_ConversionState)
	{
		// Check SPI is enabled
		_EnableSPI();

		// Read Data Bytes (16 bits)
		uint8_t tsc2046_converted_ypos_data[2] = {};
		uint8_t tsc2046_converted_xpos_data[2] = {};

		// pull CS line low to start SPI transaction
		#ifdef TSC2046_USE_HAL
			HAL_GPIO_WritePin(TS_CS_GPIO_Port, TS_CS_Pin, GPIO_PIN_RESET);
		#else
			//TS_CS_GPIO_Port->ODR &= ~TS_CS_Pin;
			_SetCsPinLow();
		#endif

		// TSC2046 READ YPOS
		#ifdef TSC2046_USE_HAL
			HAL_SPI_Transmit(&hspi2, tsc2046_read_ypos_cmd, 1, 1);
			HAL_SPI_Receive(&hspi2, tsc2046_read_ypos_data, 2, 1);
		#else
			// transmit data when TX register is empty
			_SpiTransmit8(0x90);

			 // receive data x 2 when RX register is not empty
			tsc2046_converted_ypos_data = _SpiReceive8();

			//_SpiOverflowReset();
		#endif

		// TSC2046 READ XPOS
		#ifdef TSC2046_USE_HAL
			HAL_SPI_Transmit(&hspi2, tsc2046_read_xpos_cmd, 1, 1);
			HAL_SPI_Receive(&hspi2, tsc2046_read_xpos_data, 2, 1);
		#else

			// transmit data when TX register is empty
			_SpiTransmit8(0xD0);

			// receive data x 2 when RX register is not empty
			tsc2046_converted_xpos_data = _SpiReceive8();

			//_SpiOverflowReset();
		#endif

		// pull CS line high to end SPI transaction
		#ifdef TSC2046_USE_HAL
	        HAL_GPIO_WritePin(TS_CS_GPIO_Port, TS_CS_Pin, GPIO_PIN_SET);
		#else
	        //TS_CS_GPIO_Port->ODR |= TS_CS_Pin;
	        _SetCsPinHigh();
		#endif

		#ifdef FLIP_TSC2046_COORDS
		    Positions[0] = tsc2046_converted_ypos_data;
		    Positions[1] = tsc2046_converted_xpos_data;
		#else
			Positions[0] = tsc2046_converted_xpos_data;
			Positions[1] = tsc2046_converted_ypos_data;
		#endif

	    TSC2046_HM_ConvertToQVGA(Positions);
	}
	else
	{
	    Positions[0] = 0;
	    Positions[1] = 0;
		status = TSC2046_DATAERR;
	}

	return status;

}

/*
 *
 *	@brief
 *
 *	@param None
 *	@retval
 *
 */
void TSC2046_HM_ConvertToQVGA(uint16_t pos[2])
{
	//uint16_t QVGA_HORIZON = 	320;
	//uint16_t QVGA_VERTICAL = 	240;

	pos[0] /= 100;
	pos[1] /= 100;
/*
	pos[0] *= -1;
	pos[1] *= -1;

	// inverse
	pos[0] = QVGA_HORIZON - pos[0];

	// map adc scale to pixel resolution
	pos[0] /= QVGA_HORIZON;
	pos[1] /= QVGA_VERTICAL;

	// offset
	pos[0] -= 10;			// y
	pos[1] -= 150;			// x

	// mag
	pos[0] *= 3.5;			// y
	pos[1] *= 3.5;			// x
*/
}

void _SetCsPinHigh()
{
	TS_CS_GPIO_Port->ODR |= TS_CS_Pin;
}

void _SetCsPinLow()
{
	TS_CS_GPIO_Port->ODR &= ~TS_CS_Pin;
}

void _EnableSPI()
{
	// Check SPI is enabled
	if ((TSC2046_SPI->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
	{
		TSC2046_SPI->CR1 |= SPI_CR1_SPE;
	}

}

void _SpiTransmit8(uint8_t data)
{
	if ((SPI2->SR & SPI_SR_TXE) == SPI_SR_TXE)
	{
		*(volatile uint8_t *)&(SPI2->DR) = data;
	}
}

uint8_t _SpiReceive8()
{
	uint8_t data = 0;
	if ((SPI2->SR & SPI_SR_RXNE) == SPI_SR_RXNE)
	{
		data = (uint8_t)SPI2->DR;
	}
	return data;
}

void _SpiOverflowReset()
{
	SPI2->SR &= ~(SPI_SR_OVR);		// clear SPI overrun flag, if set
}
